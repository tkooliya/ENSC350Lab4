Task 2a:

Lab doc pseudo-code:
j = 0
for i = 0 to 255 {
    j = (j + s[i] + secret_key[i mod keylength] ) mod 256 //keylength is 3 in our impl.
    swap values of s[i] and s[j]
}

Modified pseudo-code:
j = 0
for i = 0 to 255 {
    temp = s[i]
    j = (j + temp + secret_key[i mod keylength] ) mod 256
    s[i] = s[j]
    s[j] = temp
}

cycle 1:
    read s[i]

cycle 2:
    temp := q            // s[i]
    next_j := j + q + secret_key[i mod length]  // s[i]
    j <= next_j

cycle 3:
    read s[j]

cycle 4:
    write s[i] <= q     // s[j]

cycle 5:
    write s[j] <= temp
    i := i + 1



Task 2b:

Lab doc pseudo-code:

i = 0, j = 0
for k = 0 to message_length-1 { // message_length is 32 in our implementation
    i = (i + 1) mod 256
    j = (j + s[i]) mod 256

    swap values of s[i] and s[j]

    f = s[ (s[i] + s[j]) mod 256 ]
    decrypted_output[k] = f xor encrypted_input[k] // 8 bit wide XOR function
}


Modified pseudo-code:

i = 0, j = 0
for k = 0 to message_length-1 { // message_length is 32 in our implementation
    i = (i + 1) mod 256
    s_i = s[i]

    j = (j + s_i) mod 256
    s_j = s[j]

    f = s[ (s_i + s_j) mod 256 ]

    decrypted_output[k] = f xor encrypted_input[k] // 8 bit wide XOR function
    
    s[i] = s_j
    s[j] = s_i
}


cycle 1: read_i
    i <= i + 1
    read s[i + 1]

cycle 2: read_j
    s_i <= q_mem                // s[i]
    j <= j + q_mem
    read s[j + q_mem]

cycle 3: read_k
    s_j <= q_mem                // s[j]
    read s[s_i + q_mem]
    read encrypted_input[k]

cycle 4: write_k
    f := q_mem                  // s[s_i + s_j], no register needed for f
    write decrypted_output[k] <= (q_mem xor q_rom) // encrypted_input[k]

cycle 5: write_i
    write s[i] <= s_j

cycle 6: write_j
    write s[j] <= s_i
    k <= k + 1
